# Паттерны
 Паттерны проектирования (шаблоны проектирования) - готовые к использованию решения часто возникающих в программировании задач. 
## Порождающие
Предоставляют механизмы инициализации, позволяя создавать объекты удобным способом. 
* [Singleton](https://github.com/YolkaSD/pattern/tree/master/src/main/java/singleton) (Одиночка) - ограничивает создание экземпляра класса до одного, обеспечивает доступ к его единственному объекту.
* Factory (Фабрика) - используется, когда у нас есть суперкласс с несколькими подклассами и на основе ввода, нам нужно вернуть один из подкласса.
* Abstract Factory (Абстрактная фабрика) - используем супер фабрику для создания фабрики, затем используем созданную фабрику для создания объектов.
* [Builder](https://github.com/YolkaSD/pattern/tree/master/src/main/java/builder) (Строитель) - используется для создания сложного объекта с использованием простых объектов. 
* Prototype (Прототип) - помогает создать дублированный объект с лучшей производительностью, вместо нового создается возвращаемый клон существующего объекта.
## Структурные
Определяют отношения между классами и объектами, позволяя им работать совместно. 
* Adapter (Адаптер) - это конвертер между двумя несовместимыми объектами. Используя паттерн адаптера, мы можем объединить два несовместимых интерфейса.
* Composite (Компоновщик) - использует один класс для представления древовидной структуры.
* Proxy (Заместитель) - представляет функциональность другого класса.
* Flyweight (Легковес) - вместо создания большого количества похожих объектов, объекты используются повторно.
* Facade (Фасад) - обеспечивает простой интерфейс для клиента, и клиент использует интерфейс для взаимодействия с системой.
* Bridge (Мост) - делает конкретные классы независимыми от классов реализации интерфейса.
* [Decorator](https://github.com/YolkaSD/GBPatterns/tree/master/src/main/java/org/example/structural/decorator) (Декоратор) - добавляет новые функциональные возможности существующего объекта без привязки его структуры.
* [DAO](https://github.com/YolkaSD/JDBCEx1/tree/master/src/main/java/org/example/database/dao) (Data Access Object) - изолирует прикладной/бизнес-уровень от уровня сохраняемости. Dao определяет абстрактный API, который выполняет CRUD-операции над объектами типа T.
## Поведенческие
Используются для того, чтобы упростить взаимодействие между сущностями. 
* Template Method (Шаблонный метод) - определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
* Mediator (Посредник) - предоставляет класс посредника, который обрабатывает все коммуникации между различными классами.
* Chain of Responsibility (Цепочка обязанностей) - позволяет избежать жесткой зависимости отправителя запроса от его получателя, при этом запрос может быть обработан несколькими объектами.
* [Observer](https://github.com/YolkaSD/pattern/tree/master/src/main/java/Observer) (Наблюдатель) - позволяет одним объектам следить и реагировать на события, происходящие в других объектах.
* Strategy (Стратегия) - алгоритм стратегии может быть изменен во время выполнения программы.
* Command (Команда) - интерфейс команды объявляет метод для выполнения определенного действия.
* State (Состояние) - объект может изменять свое поведение в зависимости от его состояния.
* Visitor (Посетитель) - используется для упрощения операций над группировками связанных объектов.
* Interpreter (Интерпретатор) - определяет грамматику простого языка для проблемной области.
* Iterator (Итератор) - последовательно осуществляет доступ к элементам объекта коллекции, не зная его основного представления.
* Memento (Хранитель) - используется для хранения состояния объекта, позже это состояние можно восстановить.
---
# MVP
## View Presenter Model
* View - общение с пользователем 
* Presenter - связь между View и Model
* Model - работа с информацией 
---
# Command
---
# SOLID
1. Single Responsibility Principle (Принцип единственной ответственности)
2. Open CLosed Principle (Принцип открытости/закрытости)
3. Liskov's Substitution Principle (Принцип подстановки Барборы Лисков)
4. Interface Segregation Principle (Принцип разделения интерфейса)
5. Dependency Inversion Principle (Принцип инверсии зависимостей)
## Принцип единственной ответственности SRP

*Никогда не должно быть больше одной причины изменить класс*. Каждый класс должен иметь только одну зону ответственности.

## Принцип открытости/закрытости OCP

*Программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения*. Необходимо спроектировать наш код таким образом, чтобы каждый мог повторно использовать нашу функцию, просто расширив ее. (Интерфейсы)

## Принцип подстановки Барбары Лисков (LSP)

*Объекты в программе можно заменить их наследниками без изменения свойств программы.* Должна быть возможность вместо базового (родительского) типа (класса) подставить любой его подтип (класс-наследник), при этом работа программы не должна измениться.
Для того чтобы следовать принципу подстановки Барбары Лисков необходимо в базовый (родительский) класс выносить только общую логику, характерную для классов наследников, которые будут ее реализовывать и, соответственно, можно будет базовый класс без проблем заменить на его класс-наследник.

## Принцип разделения интерфейса ISP

*Клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.*

## Принцип инверсии зависимостей DIP
*Зависимости внутри системы строятся на основе абстракций.* Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
